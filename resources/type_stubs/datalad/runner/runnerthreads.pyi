import threading
from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from datalad.utils import COPY_BUFSIZE as COPY_BUFSIZE
from enum import Enum
from queue import Queue
from subprocess import Popen
from typing import Any, IO

lgr: Incomplete

class IOState(Enum):
    ok = 'ok'
    process_exit = 'process_exit'

class SignalingThread(threading.Thread):
    identifier: Incomplete
    signal_queues: Incomplete
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, bytes | None]]]) -> None: ...
    def signal(self, content: tuple[Any, IOState, bytes | None]) -> bool: ...

class WaitThread(SignalingThread):
    process: Incomplete
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, bytes | None]]], process: Popen) -> None: ...
    def run(self) -> None: ...

class ExitingThread(SignalingThread):
    exit_requested: bool
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, bytes | None]]]) -> None: ...
    def request_exit(self) -> None: ...

class TransportThread(ExitingThread, metaclass=ABCMeta):
    user_info: Incomplete
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, bytes | None]]], user_info: Any) -> None: ...
    def signal_event(self, state: IOState, data: bytes | None) -> bool: ...
    @abstractmethod
    def read(self) -> bytes | None: ...
    @abstractmethod
    def write(self, data: bytes) -> bool: ...
    def run(self) -> None: ...

class ReadThread(TransportThread):
    source: Incomplete
    destination_queue: Incomplete
    length: Incomplete
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, bytes | None]]], user_info: Any, source: IO, destination_queue: Queue[tuple[Any, IOState, bytes]], length: int = ...) -> None: ...
    def read(self) -> bytes | None: ...
    def write(self, data: bytes) -> bool: ...

class WriteThread(TransportThread):
    source_queue: Incomplete
    destination: Incomplete
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, bytes | None]]], user_info: Any, source_queue: Queue[bytes | None], destination: IO) -> None: ...
    def read(self) -> bytes | None: ...
    def write(self, data: bytes) -> bool: ...
